import { OpTypeInt } from "../types/operations";

import { BoolLit, Eq, Expr, IntLit, Ite, Not, Var } from "./grammar";

/**
 * The core function generating candidate programs from the grammar.
 * grow also encodes production rules of the grammar.
 *
 * @param programList — the current set of programs.
 * @returns — the expanded set of programs generated by enumerating all
 * possible programs of a given depth.
 */
function grow(programList: Expr[]): Expr[] {
  const expansion = [];

  // Unary operators.
  for (const p of programList) {
    if (p instanceof BoolLit || p instanceof Eq) {
      expansion.push(new Not(p));
    }
  }

  // Binary operators.
  for (const p1 of programList) {
    for (const p2 of programList) {
      if (
        (p1 instanceof IntLit || p1 instanceof Var) &&
        (p2 instanceof IntLit || p2 instanceof Var) &&
        p1 !== p2
      ) {
        expansion.push(new Eq(p1, p2));
      }
    }
  }

  // If-then-else.
  for (const p1 of programList) {
    for (const p2 of programList) {
      for (const p3 of programList) {
        if (
          p1 instanceof Eq &&
          (p2 instanceof BoolLit || p2 instanceof Eq || p2 instanceof Not) &&
          (p3 instanceof BoolLit || p3 instanceof Eq || p3 instanceof Not)
        ) {
          expansion.push(new Ite(p1, p2, p3));
        }
      }
    }
  }

  return programList.concat(expansion);
}

/**
 * The core function evaluating candidate program correctness.
 *
 * For our case, we say that a program is correct if it returns true for all concurrent pairs.
 *
 * @param program — a candidate program to evaluate.
 * @param inputs — the set of inputs to evaluate a candidate program against.
 * @returns — a Boolean flag indicating if the candidate program returns true
 * for all input pairs.
 */
function check(
  program: Expr,
  inputs: [OpTypeInt, OpTypeInt][],
  outputs: boolean[]
): boolean {
  // Enforce that any correct program should use both operations.
  const usesOps =
    program.show().includes("arg1") && program.show().includes("arg2");

  // Enforce that a correct program returns its corresponding output on all input pairs.
  const allEvalTrue = inputs.every(
    (input, i) => program.evaluate(input) === outputs[i]
  );

  return usesOps && allEvalTrue;
}

/**
 * The entry point to the synthesis engine.
 *
 * @param inputs — the set of inputs to evaluate a candidate program against.
 * @param outputs — the set of expected outputs corresponding to the inputs.
 * @returns — a set of programs satisfying the current specification.
 */
export function synthesize(
  inputs: [OpTypeInt, OpTypeInt][],
  outputs: boolean[]
): Expr[] {
  // Begin with the list of all terminals in the grammar.
  let programList: Expr[] = [
    new BoolLit(true),
    new BoolLit(false),
    new Var("arg1[0]"),
    new Var("arg2[0]"),
    new IntLit(0),
    new IntLit(1),
  ];

  const satisfyingPrograms: Expr[] = [];

  for (let i = 0; i < 2; i++) {
    // Grow the program list using production rules in the grammar.
    programList = grow(programList);

    for (const program of programList) {
      const result = check(program, inputs, outputs);

      if (result && !satisfyingPrograms.includes(program)) {
        satisfyingPrograms.push(program);
      }
    }
  }

  return satisfyingPrograms;
}
